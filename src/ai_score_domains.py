import asyncio
import json
import signal
import sys
import sqlite3
import os
import pandas as pd
from tqdm.asyncio import tqdm_asyncio
from openai import AsyncOpenAI
from utils import get_openai_key  # Ensure your utils.py defines get_openai_key()

##############################
# SQLite Database Functions  #
##############################

def init_db(db_path='data/domains.db'):
    """Initialize (or connect to) the SQLite database and create the table if it doesn't exist."""
    os.makedirs(os.path.dirname(db_path), exist_ok=True)
    conn = sqlite3.connect(db_path)
    c = conn.cursor()
    c.execute('''
        CREATE TABLE IF NOT EXISTS domain_results (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            domain TEXT UNIQUE,
            memorability REAL,
            pronunciation REAL,
            visual_appeal REAL,
            brandability REAL,
            average_score REAL,
            raw_json TEXT,
            error TEXT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    conn.commit()
    return conn

def insert_result(conn, result):
    """
    Insert or update a domain result into the database.
    result is a tuple:
    (domain, memorability, pronunciation, visual_appeal, brandability, average_score, raw_json, error)
    """
    c = conn.cursor()
    c.execute('''
        INSERT OR REPLACE INTO domain_results 
        (domain, memorability, pronunciation, visual_appeal, brandability, average_score, raw_json, error)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    ''', result)
    conn.commit()

def domain_already_processed(conn, domain):
    """Check if the domain has already been processed."""
    c = conn.cursor()
    c.execute("SELECT 1 FROM domain_results WHERE domain = ?", (domain,))
    return c.fetchone() is not None

##############################
# Setup and Signal Handling  #
##############################

# Initialize the SQLite database
conn = init_db()

# Initialize OpenAI client with o3-mini model
client = AsyncOpenAI(api_key=get_openai_key())

# Load available domains from CSV (should be generated by your previous pipeline)
df = pd.read_csv('data/domain_availability.csv')
available_df = df[df['status'] == 'Available']

# Limit concurrency to avoid rate limits (adjust as needed)
semaphore = asyncio.Semaphore(5)

# Signal handlers for graceful shutdown
def signal_handler(sig, frame):
    print("\nSignal received. Exiting gracefully...")
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)

##############################
# Async Domain Scoring       #
##############################

async def ai_score(domain):
    # Skip if already processed
    if domain_already_processed(conn, domain):
        print(f"{domain} already processed. Skipping.")
        return

    # Refined prompt using your specified format
    prompt = f"""
You are a branding expert. Evaluate the domain "{domain}" based on the following four criteria:

Memorability: How easy is it to remember the domain?

Pronunciation: How easily can it be pronounced?

Visual Appeal: How attractive is the domain when seen as text?

Brandability: How well can the domain serve as a strong, unique brand identity?

Internally analyze all aspects thoroughly, but provide your final answer as a JSON object with exactly these keys: "memorability", "pronunciation", "visual_appeal", and "brandability". Each key should map to a number from 1 (poor) to 10 (excellent). Do not include any additional text, explanations, or internal analysis in your final output.
    """
    async with semaphore:
        try:
            response = await client.chat.completions.create(
                model="o3-mini",
                messages=[{"role": "user", "content": prompt}],
                temperature=0.3,
                max_tokens=100
            )
            response_text = response.choices[0].message.content
            data = json.loads(response_text)
            # Compute an equal-weighted average score
            avg_score = sum(data.values()) / len(data)
            print(f"{domain}: {avg_score}")
            result = (
                domain,
                data.get("memorability"),
                data.get("pronunciation"),
                data.get("visual_appeal"),
                data.get("brandability"),
                avg_score,
                response_text,
                None  # No error
            )
            insert_result(conn, result)
            return result
        except Exception as e:
            err_msg = str(e)
            print(f"{domain}: Error scoring ({err_msg})")
            result = (domain, None, None, None, None, None, None, err_msg)
            insert_result(conn, result)
            return result

async def main():
    tasks = [ai_score(row['domain']) for _, row in available_df.iterrows()]
    # Process tasks with an asynchronous progress bar
    async for _ in tqdm_asyncio.as_completed(tasks, desc="Scoring Domains", total=len(tasks)):
        pass

if __name__ == "__main__":
    asyncio.run(main())
